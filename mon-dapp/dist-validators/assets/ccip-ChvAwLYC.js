import{dt as b,du as x,dv as F,dw as D,dx as G,dy as M,dz as E,dA as T,dB as w,dC as v,dD as R,dE as H,dF as _,dG as m,dH as j,dI as A,dJ as O,dK as y,dL as P,dM as N,dN as B,dO as U,dP as z,dQ as L,dR as J}from"./main-fJPeS9Wm.js";function K(t){const{abi:s,data:a}=t,r=b(a,0,4),e=s.find(n=>n.type==="function"&&r===x(F(n)));if(!e)throw new D(r,{docsPath:"/docs/contract/decodeFunctionData"});return{functionName:e.name,args:"inputs"in e&&e.inputs&&e.inputs.length>0?G(e.inputs,b(a,4)):void 0}}const p="/docs/contract/encodeErrorResult";function k(t){const{abi:s,errorName:a,args:r}=t;let e=s[0];if(a){const u=M({abi:s,args:r,name:a});if(!u)throw new E(a,{docsPath:p});e=u}if(e.type!=="error")throw new E(void 0,{docsPath:p});const n=F(e),o=x(n);let c="0x";if(r&&r.length>0){if(!e.inputs)throw new T(e.name,{docsPath:p});c=w(e.inputs,r)}return v([o,c])}const h="/docs/contract/encodeFunctionResult";function Q(t){const{abi:s,functionName:a,result:r}=t;let e=s[0];if(a){const o=M({abi:s,name:a});if(!o)throw new R(a,{docsPath:h});e=o}if(e.type!=="function")throw new R(void 0,{docsPath:h});if(!e.outputs)throw new H(e.name,{docsPath:h});const n=(()=>{if(e.outputs.length===0)return[];if(e.outputs.length===1)return[r];if(Array.isArray(r))return r;throw new _(r)})();return w(e.outputs,n)}const S="x-batch-gateway:true";async function q(t){const{data:s,ccipRequest:a}=t,{args:[r]}=K({abi:m,data:s}),e=[],n=[];return await Promise.all(r.map(async(o,c)=>{try{n[c]=o.urls.includes(S)?await q({data:o.data,ccipRequest:a}):await a(o),e[c]=!1}catch(u){e[c]=!0,n[c]=W(u)}})),Q({abi:m,functionName:"query",result:[e,n]})}function W(t){return t.name==="HttpRequestError"&&t.status?k({abi:m,errorName:"HttpError",args:[t.status,t.shortMessage]}):k({abi:[j],errorName:"Error",args:["shortMessage"in t?t.shortMessage:t.message]})}function V(t,s){if(!A(t,{strict:!1}))throw new O({address:t});if(!A(s,{strict:!1}))throw new O({address:s});return t.toLowerCase()===s.toLowerCase()}class X extends y{constructor({callbackSelector:s,cause:a,data:r,extraData:e,sender:n,urls:o}){super(a.shortMessage||"An error occurred while fetching for an offchain result.",{cause:a,metaMessages:[...a.metaMessages||[],a.metaMessages?.length?"":[],"Offchain Gateway Call:",o&&["  Gateway URL(s):",...o.map(c=>`    ${P(c)}`)],`  Sender: ${n}`,`  Data: ${r}`,`  Callback selector: ${s}`,`  Extra data: ${e}`].flat(),name:"OffchainLookupError"})}}class Y extends y{constructor({result:s,url:a}){super("Offchain gateway response is malformed. Response data must be a hex value.",{metaMessages:[`Gateway URL: ${P(a)}`,`Response: ${N(s)}`],name:"OffchainLookupResponseMalformedError"})}}class Z extends y{constructor({sender:s,to:a}){super("Reverted sender address does not match target contract address (`to`).",{metaMessages:[`Contract address: ${a}`,`OffchainLookup sender address: ${s}`],name:"OffchainLookupSenderMismatchError"})}}const ee="0x556f1830",$={name:"OffchainLookup",type:"error",inputs:[{name:"sender",type:"address"},{name:"urls",type:"string[]"},{name:"callData",type:"bytes"},{name:"callbackFunction",type:"bytes4"},{name:"extraData",type:"bytes"}]};async function te(t,{blockNumber:s,blockTag:a,data:r,to:e}){const{args:n}=B({data:r,abi:[$]}),[o,c,u,i,d]=n,{ccipRead:f}=t,g=f&&typeof f?.request=="function"?f.request:C;try{if(!V(e,o))throw new Z({sender:o,to:e});const l=c.includes(S)?await q({data:u,ccipRequest:g}):await g({data:u,sender:o,urls:c}),{data:I}=await U(t,{blockNumber:s,blockTag:a,data:z([i,w([{type:"bytes"},{type:"bytes"}],[l,d])]),to:e});return I}catch(l){throw new X({callbackSelector:i,cause:l,data:r,extraData:d,sender:o,urls:c})}}async function C({data:t,sender:s,urls:a}){let r=new Error("An unknown error occurred.");for(let e=0;e<a.length;e++){const n=a[e],o=n.includes("{data}")?"GET":"POST",c=o==="POST"?{data:t,sender:s}:void 0,u=o==="POST"?{"Content-Type":"application/json"}:{};try{const i=await fetch(n.replace("{sender}",s.toLowerCase()).replace("{data}",t),{body:JSON.stringify(c),headers:u,method:o});let d;if(i.headers.get("Content-Type")?.startsWith("application/json")?d=(await i.json()).data:d=await i.text(),!i.ok){r=new L({body:c,details:d?.error?N(d.error):i.statusText,headers:i.headers,status:i.status,url:n});continue}if(!J(d)){r=new Y({result:d,url:n});continue}return d}catch(i){r=new L({body:c,details:i.message,url:n})}}throw r}const se=Object.freeze(Object.defineProperty({__proto__:null,ccipRequest:C,offchainLookup:te,offchainLookupAbiItem:$,offchainLookupSignature:ee},Symbol.toStringTag,{value:"Module"}));export{Q as a,$ as b,C as c,K as d,k as e,ee as f,se as g,V as i,S as l,te as o};
