import{cF as ne,ea as L,cz as v,cx as h,cX as S,eb as se,cW as P,ec as pe,cy as k,cA as U,cV as q,d9 as O,cT as re,cQ as ae,cR as w,db as me,d1 as j,da as ye}from"./main-fJPeS9Wm.js";import{r as N,c as ie}from"./index-D1QK5nkj.js";import{o as X}from"./if-defined-B62JGHpA.js";import"./index-3e7z63an.js";import"./index-DOWKVF6h.js";import"./index-tC4FIWcp.js";import"./index-Cm2rnjkP.js";import"./index-DrzApZEH.js";import"./index-Ct7z9X_3.js";import"./index-ZZoYeELI.js";import"./index-CfpuMtvc.js";import"./index-Dhde9jAi.js";import"./index-BUVJjIpA.js";import"./index-BKxxNevL.js";const fe=Symbol(),J=Object.getPrototypeOf,Z=new WeakMap,he=t=>t&&(Z.has(t)?Z.get(t):J(t)===Object.prototype||J(t)===Array.prototype),we=t=>he(t)&&t[fe]||null,H={},K=t=>typeof t=="object"&&t!==null,Ee=t=>K(t)&&!oe.has(t)&&(Array.isArray(t)||!(Symbol.iterator in t))&&!(t instanceof WeakMap)&&!(t instanceof WeakSet)&&!(t instanceof Error)&&!(t instanceof Number)&&!(t instanceof Date)&&!(t instanceof String)&&!(t instanceof RegExp)&&!(t instanceof ArrayBuffer)&&!(t instanceof Promise),ge=(t,e,n,r)=>({deleteProperty(i,a){const o=Reflect.get(i,a);n(a);const d=Reflect.deleteProperty(i,a);return d&&r(["delete",[a],o]),d},set(i,a,o,d){const m=!t()&&Reflect.has(i,a),E=Reflect.get(i,a,d);if(m&&(Q(E,o)||G.has(o)&&Q(E,G.get(o))))return!0;n(a),K(o)&&(o=we(o)||o);const g=!M.has(o)&&Ie(o)?ce(o):o;return e(a,g),Reflect.set(i,a,g,d),r(["set",[a],o,E]),!0}}),M=new WeakMap,oe=new WeakSet,$=[1],G=new WeakMap;let Q=Object.is,Ae=(t,e)=>new Proxy(t,e),Ie=Ee,Ne=ge;function ce(t={}){if(!K(t))throw new Error("object required");const e=G.get(t);if(e)return e;let n=$[0];const r=new Set,i=(p,f=++$[0])=>{n!==f&&(a=n=f,r.forEach(y=>y(p,f)))};let a=n;const o=(p=$[0])=>(a!==p&&(a=p,m.forEach(([f])=>{const y=f[1](p);y>n&&(n=y)})),n),d=p=>(f,y)=>{const A=[...f];A[1]=[p,...A[1]],i(A,y)},m=new Map,E=(p,f)=>{const y=!oe.has(f)&&M.get(f);if(y){if((H?"production":void 0)!=="production"&&m.has(p))throw new Error("prop listener already exists");if(r.size){const A=y[2](d(p));m.set(p,[y,A])}else m.set(p,[y])}},g=p=>{var f;const y=m.get(p);y&&(m.delete(p),(f=y[1])==null||f.call(y))},T=p=>(r.add(p),r.size===1&&m.forEach(([y,A],D)=>{if((H?"production":void 0)!=="production"&&A)throw new Error("remove already exists");const de=y[2](d(D));m.set(D,[y,de])}),()=>{r.delete(p),r.size===0&&m.forEach(([y,A],D)=>{A&&(A(),m.set(D,[y]))})});let C=!0;const V=Ne(()=>C,E,g,i),R=Ae(t,V);G.set(t,R);const le=[t,o,T];return M.set(R,le),Reflect.ownKeys(t).forEach(p=>{const f=Object.getOwnPropertyDescriptor(t,p);"value"in f&&f.writable&&(R[p]=t[p])}),C=!1,R}function ue(t,e,n){const r=M.get(t);(H?"production":void 0)!=="production"&&!r&&console.warn("Please use proxy object");let i;const a=[],o=r[2];let d=!1;const E=o(g=>{a.push(g),i||(i=Promise.resolve().then(()=>{i=void 0,d&&e(a.splice(0))}))});return d=!0,()=>{d=!1,E()}}function Pe(t,e,n,r){let i=t[e];return ue(t,()=>{const a=t[e];Object.is(i,a)||n(i=a)})}const c={INVALID_PAYMENT_CONFIG:"INVALID_PAYMENT_CONFIG",INVALID_RECIPIENT:"INVALID_RECIPIENT",INVALID_ASSET:"INVALID_ASSET",INVALID_AMOUNT:"INVALID_AMOUNT",UNKNOWN_ERROR:"UNKNOWN_ERROR",UNABLE_TO_INITIATE_PAYMENT:"UNABLE_TO_INITIATE_PAYMENT",INVALID_CHAIN_NAMESPACE:"INVALID_CHAIN_NAMESPACE",GENERIC_PAYMENT_ERROR:"GENERIC_PAYMENT_ERROR",UNABLE_TO_GET_EXCHANGES:"UNABLE_TO_GET_EXCHANGES",ASSET_NOT_SUPPORTED:"ASSET_NOT_SUPPORTED",UNABLE_TO_GET_PAY_URL:"UNABLE_TO_GET_PAY_URL",UNABLE_TO_GET_BUY_STATUS:"UNABLE_TO_GET_BUY_STATUS"},b={[c.INVALID_PAYMENT_CONFIG]:"Invalid payment configuration",[c.INVALID_RECIPIENT]:"Invalid recipient address",[c.INVALID_ASSET]:"Invalid asset specified",[c.INVALID_AMOUNT]:"Invalid payment amount",[c.UNKNOWN_ERROR]:"Unknown payment error occurred",[c.UNABLE_TO_INITIATE_PAYMENT]:"Unable to initiate payment",[c.INVALID_CHAIN_NAMESPACE]:"Invalid chain namespace",[c.GENERIC_PAYMENT_ERROR]:"Unable to process payment",[c.UNABLE_TO_GET_EXCHANGES]:"Unable to get exchanges",[c.ASSET_NOT_SUPPORTED]:"Asset not supported by the selected exchange",[c.UNABLE_TO_GET_PAY_URL]:"Unable to get payment URL",[c.UNABLE_TO_GET_BUY_STATUS]:"Unable to get buy status"};class u extends Error{get message(){return b[this.code]}constructor(e,n){super(b[e]),this.name="AppKitPayError",this.code=e,this.details=n,Error.captureStackTrace&&Error.captureStackTrace(this,u)}}const _e="https://rpc.walletconnect.org/v1/json-rpc";class Se extends Error{}function Te(){const t=ne.getSnapshot().projectId;return`${_e}?projectId=${t}`}async function z(t,e){const n=Te(),{sdkType:r,sdkVersion:i,projectId:a}=ne.getSnapshot(),o={jsonrpc:"2.0",id:1,method:t,params:{...e||{},st:r,sv:i,projectId:a}},m=await(await fetch(n,{method:"POST",body:JSON.stringify(o),headers:{"Content-Type":"application/json"}})).json();if(m.error)throw new Se(m.error.message);return m}async function ee(t){return(await z("reown_getExchanges",t)).result}async function Ce(t){return(await z("reown_getExchangePayUrl",t)).result}async function be(t){return(await z("reown_getExchangeBuyStatus",t)).result}const xe=["eip155","solana"],ke={eip155:{native:{assetNamespace:"slip44",assetReference:"60"},defaultTokenNamespace:"erc20"},solana:{native:{assetNamespace:"slip44",assetReference:"501"},defaultTokenNamespace:"token"}};function W(t,e){const{chainNamespace:n,chainId:r}=L.parseCaipNetworkId(t),i=ke[n];if(!i)throw new Error(`Unsupported chain namespace for CAIP-19 formatting: ${n}`);let a=i.native.assetNamespace,o=i.native.assetReference;return e!=="native"&&(a=i.defaultTokenNamespace,o=e),`${`${n}:${r}`}/${a}:${o}`}function ve(t){const{chainNamespace:e}=L.parseCaipNetworkId(t);return xe.includes(e)}async function Ue(t){const{paymentAssetNetwork:e,activeCaipNetwork:n,approvedCaipNetworkIds:r,requestedCaipNetworks:i}=t,o=v.sortRequestedNetworks(r,i).find(E=>E.caipNetworkId===e);if(!o)throw new u(c.INVALID_PAYMENT_CONFIG);if(o.caipNetworkId===n.caipNetworkId)return;const d=h.getNetworkProp("supportsAllNetworks",o.chainNamespace);if(!(r?.includes(o.caipNetworkId)||d))throw new u(c.INVALID_PAYMENT_CONFIG);try{await h.switchActiveNetwork(o)}catch(E){throw new u(c.GENERIC_PAYMENT_ERROR,E)}}async function Re(t,e,n){if(e!==S.CHAIN.EVM)throw new u(c.INVALID_CHAIN_NAMESPACE);if(!n.fromAddress)throw new u(c.INVALID_PAYMENT_CONFIG,"fromAddress is required for native EVM payments.");const r=typeof n.amount=="string"?parseFloat(n.amount):n.amount;if(isNaN(r))throw new u(c.INVALID_PAYMENT_CONFIG);const i=t.metadata?.decimals??18,a=P.parseUnits(r.toString(),i);if(typeof a!="bigint")throw new u(c.GENERIC_PAYMENT_ERROR);return await P.sendTransaction({chainNamespace:e,to:n.recipient,address:n.fromAddress,value:a,data:"0x"})??void 0}async function De(t,e){if(!e.fromAddress)throw new u(c.INVALID_PAYMENT_CONFIG,"fromAddress is required for ERC20 EVM payments.");const n=t.asset,r=e.recipient,i=Number(t.metadata.decimals),a=P.parseUnits(e.amount.toString(),i);if(a===void 0)throw new u(c.GENERIC_PAYMENT_ERROR);return await P.writeContract({fromAddress:e.fromAddress,tokenAddress:n,args:[r,a],method:"transfer",abi:pe.getERC20Abi(n),chainNamespace:S.CHAIN.EVM})??void 0}async function Le(t,e){if(t!==S.CHAIN.SOLANA)throw new u(c.INVALID_CHAIN_NAMESPACE);if(!e.fromAddress)throw new u(c.INVALID_PAYMENT_CONFIG,"fromAddress is required for Solana payments.");const n=typeof e.amount=="string"?parseFloat(e.amount):e.amount;if(isNaN(n)||n<=0)throw new u(c.INVALID_PAYMENT_CONFIG,"Invalid payment amount.");try{if(!se.getProvider(t))throw new u(c.GENERIC_PAYMENT_ERROR,"No Solana provider available.");const i=await P.sendTransaction({chainNamespace:S.CHAIN.SOLANA,to:e.recipient,value:n,tokenMint:e.tokenMint});if(!i)throw new u(c.GENERIC_PAYMENT_ERROR,"Transaction failed.");return i}catch(r){throw r instanceof u?r:new u(c.GENERIC_PAYMENT_ERROR,`Solana payment failed: ${r}`)}}const te=0,B="unknown",s=ce({paymentAsset:{network:"eip155:1",asset:"0x0",metadata:{name:"0x0",symbol:"0x0",decimals:0}},recipient:"0x0",amount:0,isConfigured:!1,error:null,isPaymentInProgress:!1,exchanges:[],isLoading:!1,openInNewTab:!0,redirectUrl:void 0,payWithExchange:void 0,currentPayment:void 0,analyticsSet:!1,paymentId:void 0}),l={state:s,subscribe(t){return ue(s,()=>t(s))},subscribeKey(t,e){return Pe(s,t,e)},async handleOpenPay(t){this.resetState(),this.setPaymentConfig(t),this.subscribeEvents(),this.initializeAnalytics(),s.isConfigured=!0,k.sendEvent({type:"track",event:"PAY_MODAL_OPEN",properties:{exchanges:s.exchanges,configuration:{network:s.paymentAsset.network,asset:s.paymentAsset.asset,recipient:s.recipient,amount:s.amount}}}),await O.open({view:"Pay"})},resetState(){s.paymentAsset={network:"eip155:1",asset:"0x0",metadata:{name:"0x0",symbol:"0x0",decimals:0}},s.recipient="0x0",s.amount=0,s.isConfigured=!1,s.error=null,s.isPaymentInProgress=!1,s.isLoading=!1,s.currentPayment=void 0},setPaymentConfig(t){if(!t.paymentAsset)throw new u(c.INVALID_PAYMENT_CONFIG);try{s.paymentAsset=t.paymentAsset,s.recipient=t.recipient,s.amount=t.amount,s.openInNewTab=t.openInNewTab??!0,s.redirectUrl=t.redirectUrl,s.payWithExchange=t.payWithExchange,s.error=null}catch(e){throw new u(c.INVALID_PAYMENT_CONFIG,e.message)}},getPaymentAsset(){return s.paymentAsset},getExchanges(){return s.exchanges},async fetchExchanges(){try{s.isLoading=!0;const t=await ee({page:te,asset:W(s.paymentAsset.network,s.paymentAsset.asset),amount:s.amount.toString()});s.exchanges=t.exchanges.slice(0,2)}catch{throw U.showError(b.UNABLE_TO_GET_EXCHANGES),new u(c.UNABLE_TO_GET_EXCHANGES)}finally{s.isLoading=!1}},async getAvailableExchanges(t){try{const e=t?.asset&&t?.network?W(t.network,t.asset):void 0;return await ee({page:t?.page??te,asset:e,amount:t?.amount?.toString()})}catch{throw new u(c.UNABLE_TO_GET_EXCHANGES)}},async getPayUrl(t,e,n=!1){try{const r=Number(e.amount),i=await Ce({exchangeId:t,asset:W(e.network,e.asset),amount:r.toString(),recipient:`${e.network}:${e.recipient}`});return k.sendEvent({type:"track",event:"PAY_EXCHANGE_SELECTED",properties:{source:"pay",exchange:{id:t},configuration:{network:e.network,asset:e.asset,recipient:e.recipient,amount:r},currentPayment:{type:"exchange",exchangeId:t},headless:n}}),n&&(this.initiatePayment(),k.sendEvent({type:"track",event:"PAY_INITIATED",properties:{source:"pay",paymentId:s.paymentId||B,configuration:{network:e.network,asset:e.asset,recipient:e.recipient,amount:r},currentPayment:{type:"exchange",exchangeId:t}}})),i}catch(r){throw r instanceof Error&&r.message.includes("is not supported")?new u(c.ASSET_NOT_SUPPORTED):new Error(r.message)}},async openPayUrl(t,e,n=!1){try{const r=await this.getPayUrl(t.exchangeId,e,n);if(!r)throw new u(c.UNABLE_TO_GET_PAY_URL);const a=t.openInNewTab??!0?"_blank":"_self";return v.openHref(r.url,a),r}catch(r){throw r instanceof u?s.error=r.message:s.error=b.GENERIC_PAYMENT_ERROR,new u(c.UNABLE_TO_GET_PAY_URL)}},subscribeEvents(){s.isConfigured||(P.subscribeKey("connections",t=>{t.size>0&&this.handlePayment()}),h.subscribeChainProp("accountState",t=>{const e=P.hasAnyConnection(S.CONNECTOR_ID.WALLET_CONNECT);t?.caipAddress&&(e?setTimeout(()=>{this.handlePayment()},100):this.handlePayment())}))},async handlePayment(){s.currentPayment={type:"wallet",status:"IN_PROGRESS"};const t=h.getActiveCaipAddress();if(!t)return;const{chainId:e,address:n}=L.parseCaipAddress(t),r=h.state.activeChain;if(!n||!e||!r||!se.getProvider(r))return;const a=h.state.activeCaipNetwork;if(a&&!s.isPaymentInProgress)try{this.initiatePayment();const o=h.getAllRequestedCaipNetworks(),d=h.getAllApprovedCaipNetworkIds();switch(await Ue({paymentAssetNetwork:s.paymentAsset.network,activeCaipNetwork:a,approvedCaipNetworkIds:d,requestedCaipNetworks:o}),await O.open({view:"PayLoading"}),r){case S.CHAIN.EVM:s.paymentAsset.asset==="native"&&(s.currentPayment.result=await Re(s.paymentAsset,r,{recipient:s.recipient,amount:s.amount,fromAddress:n})),s.paymentAsset.asset.startsWith("0x")&&(s.currentPayment.result=await De(s.paymentAsset,{recipient:s.recipient,amount:s.amount,fromAddress:n})),s.currentPayment.status="SUCCESS";break;case S.CHAIN.SOLANA:s.currentPayment.result=await Le(r,{recipient:s.recipient,amount:s.amount,fromAddress:n,tokenMint:s.paymentAsset.asset==="native"?void 0:s.paymentAsset.asset}),s.currentPayment.status="SUCCESS";break;default:throw new u(c.INVALID_CHAIN_NAMESPACE)}}catch(o){o instanceof u?s.error=o.message:s.error=b.GENERIC_PAYMENT_ERROR,s.currentPayment.status="FAILED",U.showError(s.error)}finally{s.isPaymentInProgress=!1}},getExchangeById(t){return s.exchanges.find(e=>e.id===t)},validatePayConfig(t){const{paymentAsset:e,recipient:n,amount:r}=t;if(!e)throw new u(c.INVALID_PAYMENT_CONFIG);if(!n)throw new u(c.INVALID_RECIPIENT);if(!e.asset)throw new u(c.INVALID_ASSET);if(r==null||r<=0)throw new u(c.INVALID_AMOUNT)},handlePayWithWallet(){const t=h.getActiveCaipAddress();if(!t){q.push("Connect");return}const{chainId:e,address:n}=L.parseCaipAddress(t),r=h.state.activeChain;if(!n||!e||!r){q.push("Connect");return}this.handlePayment()},async handlePayWithExchange(t){try{s.currentPayment={type:"exchange",exchangeId:t};const{network:e,asset:n}=s.paymentAsset,r={network:e,asset:n,amount:s.amount,recipient:s.recipient},i=await this.getPayUrl(t,r);if(!i)throw new u(c.UNABLE_TO_INITIATE_PAYMENT);return s.currentPayment.sessionId=i.sessionId,s.currentPayment.status="IN_PROGRESS",s.currentPayment.exchangeId=t,this.initiatePayment(),{url:i.url,openInNewTab:s.openInNewTab}}catch(e){return e instanceof u?s.error=e.message:s.error=b.GENERIC_PAYMENT_ERROR,s.isPaymentInProgress=!1,U.showError(s.error),null}},async getBuyStatus(t,e){try{const n=await be({sessionId:e,exchangeId:t});return(n.status==="SUCCESS"||n.status==="FAILED")&&k.sendEvent({type:"track",event:n.status==="SUCCESS"?"PAY_SUCCESS":"PAY_ERROR",properties:{message:n.status==="FAILED"?v.parseError(s.error):void 0,source:"pay",paymentId:s.paymentId||B,configuration:{network:s.paymentAsset.network,asset:s.paymentAsset.asset,recipient:s.recipient,amount:s.amount},currentPayment:{type:"exchange",exchangeId:s.currentPayment?.exchangeId,sessionId:s.currentPayment?.sessionId,result:n.txHash}}}),n}catch{throw new u(c.UNABLE_TO_GET_BUY_STATUS)}},async updateBuyStatus(t,e){try{const n=await this.getBuyStatus(t,e);s.currentPayment&&(s.currentPayment.status=n.status,s.currentPayment.result=n.txHash),(n.status==="SUCCESS"||n.status==="FAILED")&&(s.isPaymentInProgress=!1)}catch{throw new u(c.UNABLE_TO_GET_BUY_STATUS)}},initiatePayment(){s.isPaymentInProgress=!0,s.paymentId=crypto.randomUUID()},initializeAnalytics(){s.analyticsSet||(s.analyticsSet=!0,this.subscribeKey("isPaymentInProgress",t=>{if(s.currentPayment?.status&&s.currentPayment.status!=="UNKNOWN"){const e={IN_PROGRESS:"PAY_INITIATED",SUCCESS:"PAY_SUCCESS",FAILED:"PAY_ERROR"}[s.currentPayment.status];k.sendEvent({type:"track",event:e,properties:{message:s.currentPayment.status==="FAILED"?v.parseError(s.error):void 0,source:"pay",paymentId:s.paymentId||B,configuration:{network:s.paymentAsset.network,asset:s.paymentAsset.asset,recipient:s.recipient,amount:s.amount},currentPayment:{type:s.currentPayment.type,exchangeId:s.currentPayment.exchangeId,sessionId:s.currentPayment.sessionId,result:s.currentPayment.result}}})}}))}},Oe=re`
  wui-separator {
    margin: var(--apkt-spacing-3) calc(var(--apkt-spacing-3) * -1) var(--apkt-spacing-2)
      calc(var(--apkt-spacing-3) * -1);
    width: calc(100% + var(--apkt-spacing-3) * 2);
  }

  .token-display {
    padding: var(--apkt-spacing-3) var(--apkt-spacing-3);
    border-radius: var(--apkt-borderRadius-5);
    background-color: var(--apkt-tokens-theme-backgroundPrimary);
    margin-top: var(--apkt-spacing-3);
    margin-bottom: var(--apkt-spacing-3);
  }

  .token-display wui-text {
    text-transform: none;
  }

  wui-loading-spinner {
    padding: var(--apkt-spacing-2);
  }
`;var _=function(t,e,n,r){var i=arguments.length,a=i<3?e:r===null?r=Object.getOwnPropertyDescriptor(e,n):r,o;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")a=Reflect.decorate(t,e,n,r);else for(var d=t.length-1;d>=0;d--)(o=t[d])&&(a=(i<3?o(a):i>3?o(e,n,a):o(e,n))||a);return i>3&&a&&Object.defineProperty(e,n,a),a};let I=class extends ae{constructor(){super(),this.unsubscribe=[],this.amount="",this.tokenSymbol="",this.networkName="",this.exchanges=l.state.exchanges,this.isLoading=l.state.isLoading,this.loadingExchangeId=null,this.connectedWalletInfo=h.getAccountData()?.connectedWalletInfo,this.initializePaymentDetails(),this.unsubscribe.push(l.subscribeKey("exchanges",e=>this.exchanges=e)),this.unsubscribe.push(l.subscribeKey("isLoading",e=>this.isLoading=e)),this.unsubscribe.push(h.subscribeChainProp("accountState",e=>{this.connectedWalletInfo=e?.connectedWalletInfo})),l.fetchExchanges()}get isWalletConnected(){return h.getAccountData()?.status==="connected"}render(){return w`
      <wui-flex flexDirection="column">
        <wui-flex flexDirection="column" .padding=${["0","4","4","4"]} gap="3">
          ${this.renderPaymentHeader()}

          <wui-flex flexDirection="column" gap="3">
            ${this.renderPayWithWallet()} ${this.renderExchangeOptions()}
          </wui-flex>
        </wui-flex>
      </wui-flex>
    `}initializePaymentDetails(){const e=l.getPaymentAsset();this.networkName=e.network,this.tokenSymbol=e.metadata.symbol,this.amount=l.state.amount.toString()}renderPayWithWallet(){return ve(this.networkName)?w`<wui-flex flexDirection="column" gap="3">
        ${this.isWalletConnected?this.renderConnectedView():this.renderDisconnectedView()}
      </wui-flex>
      <wui-separator text="or"></wui-separator>`:w``}renderPaymentHeader(){let e=this.networkName;if(this.networkName){const r=h.getAllRequestedCaipNetworks().find(i=>i.caipNetworkId===this.networkName);r&&(e=r.name)}return w`
      <wui-flex flexDirection="column" alignItems="center">
        <wui-flex alignItems="center" gap="2">
          <wui-text variant="h1-regular" color="primary">${this.amount||"0.0000"}</wui-text>
          <wui-flex class="token-display" alignItems="center" gap="1">
            <wui-text variant="md-medium" color="primary">
              ${this.tokenSymbol||"Unknown Asset"}
            </wui-text>
            ${e?w`
                  <wui-text variant="sm-medium" color="secondary">
                    on ${e}
                  </wui-text>
                `:""}
          </wui-flex>
        </wui-flex>
      </wui-flex>
    `}renderConnectedView(){const e=this.connectedWalletInfo?.name||"connected wallet";return w`
      <wui-list-item
        @click=${this.onWalletPayment}
        ?chevron=${!0}
        ?fullSize=${!0}
        ?rounded=${!0}
        data-testid="wallet-payment-option"
        imageSrc=${X(this.connectedWalletInfo?.icon)}
      >
        <wui-text variant="lg-regular" color="primary">Pay with ${e}</wui-text>
      </wui-list-item>

      <wui-list-item
        icon="power"
        ?rounded=${!0}
        iconColor="error"
        @click=${this.onDisconnect}
        data-testid="disconnect-button"
        ?chevron=${!1}
      >
        <wui-text variant="lg-regular" color="secondary">Disconnect</wui-text>
      </wui-list-item>
    `}renderDisconnectedView(){return w`<wui-list-item
      variant="icon"
      iconVariant="overlay"
      icon="wallet"
      ?rounded=${!0}
      @click=${this.onWalletPayment}
      ?chevron=${!0}
      data-testid="wallet-payment-option"
    >
      <wui-text variant="lg-regular" color="primary">Pay from wallet</wui-text>
    </wui-list-item>`}renderExchangeOptions(){return this.isLoading?w`<wui-flex justifyContent="center" alignItems="center">
        <wui-spinner size="md"></wui-spinner>
      </wui-flex>`:this.exchanges.length===0?w`<wui-flex justifyContent="center" alignItems="center">
        <wui-text variant="md-medium" color="primary">No exchanges available</wui-text>
      </wui-flex>`:this.exchanges.map(e=>w`
        <wui-list-item
          @click=${()=>this.onExchangePayment(e.id)}
          data-testid="exchange-option-${e.id}"
          ?chevron=${!0}
          ?disabled=${this.loadingExchangeId!==null}
          ?loading=${this.loadingExchangeId===e.id}
          imageSrc=${X(e.imageUrl)}
        >
          <wui-flex alignItems="center" gap="3">
            <wui-text flexGrow="1" variant="md-medium" color="primary"
              >Pay with ${e.name} <wui-spinner size="sm" color="secondary"></wui-spinner
            ></wui-text>
          </wui-flex>
        </wui-list-item>
      `)}onWalletPayment(){l.handlePayWithWallet()}async onExchangePayment(e){try{this.loadingExchangeId=e;const n=await l.handlePayWithExchange(e);n&&(await O.open({view:"PayLoading"}),v.openHref(n.url,n.openInNewTab?"_blank":"_self"))}catch(n){console.error("Failed to pay with exchange",n),U.showError("Failed to pay with exchange")}finally{this.loadingExchangeId=null}}async onDisconnect(e){e.stopPropagation();try{await P.disconnect()}catch{console.error("Failed to disconnect"),U.showError("Failed to disconnect")}}disconnectedCallback(){this.unsubscribe.forEach(e=>e())}};I.styles=Oe;_([N()],I.prototype,"amount",void 0);_([N()],I.prototype,"tokenSymbol",void 0);_([N()],I.prototype,"networkName",void 0);_([N()],I.prototype,"exchanges",void 0);_([N()],I.prototype,"isLoading",void 0);_([N()],I.prototype,"loadingExchangeId",void 0);_([N()],I.prototype,"connectedWalletInfo",void 0);I=_([ie("w3m-pay-view")],I);const Me=re`
  :host {
    display: block;
    height: 100%;
    width: 100%;
  }

  wui-flex:first-child:not(:only-child) {
    position: relative;
  }

  wui-loading-thumbnail {
    position: absolute;
  }
`;var Y=function(t,e,n,r){var i=arguments.length,a=i<3?e:r===null?r=Object.getOwnPropertyDescriptor(e,n):r,o;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")a=Reflect.decorate(t,e,n,r);else for(var d=t.length-1;d>=0;d--)(o=t[d])&&(a=(i<3?o(a):i>3?o(e,n,a):o(e,n))||a);return i>3&&a&&Object.defineProperty(e,n,a),a};const Ge=4e3;let x=class extends ae{constructor(){super(),this.loadingMessage="",this.subMessage="",this.paymentState="in-progress",this.paymentState=l.state.isPaymentInProgress?"in-progress":"completed",this.updateMessages(),this.setupSubscription(),this.setupExchangeSubscription()}disconnectedCallback(){clearInterval(this.exchangeSubscription)}render(){return w`
      <wui-flex
        flexDirection="column"
        alignItems="center"
        .padding=${["7","5","5","5"]}
        gap="9"
      >
        <wui-flex justifyContent="center" alignItems="center"> ${this.getStateIcon()} </wui-flex>
        <wui-flex flexDirection="column" alignItems="center" gap="2">
          <wui-text align="center" variant="lg-medium" color="primary">
            ${this.loadingMessage}
          </wui-text>
          <wui-text align="center" variant="lg-regular" color="secondary">
            ${this.subMessage}
          </wui-text>
        </wui-flex>
      </wui-flex>
    `}updateMessages(){switch(this.paymentState){case"completed":this.loadingMessage="Payment completed",this.subMessage="Your transaction has been successfully processed";break;case"error":this.loadingMessage="Payment failed",this.subMessage="There was an error processing your transaction";break;case"in-progress":default:l.state.currentPayment?.type==="exchange"?(this.loadingMessage="Payment initiated",this.subMessage="Please complete the payment on the exchange"):(this.loadingMessage="Awaiting payment confirmation",this.subMessage="Please confirm the payment transaction in your wallet");break}}getStateIcon(){switch(this.paymentState){case"completed":return this.successTemplate();case"error":return this.errorTemplate();case"in-progress":default:return this.loaderTemplate()}}setupExchangeSubscription(){l.state.currentPayment?.type==="exchange"&&(this.exchangeSubscription=setInterval(async()=>{const e=l.state.currentPayment?.exchangeId,n=l.state.currentPayment?.sessionId;e&&n&&(await l.updateBuyStatus(e,n),l.state.currentPayment?.status==="SUCCESS"&&clearInterval(this.exchangeSubscription))},Ge))}setupSubscription(){l.subscribeKey("isPaymentInProgress",e=>{!e&&this.paymentState==="in-progress"&&(l.state.error||!l.state.currentPayment?.result?this.paymentState="error":this.paymentState="completed",this.updateMessages(),setTimeout(()=>{P.state.status!=="disconnected"&&O.close()},3e3))}),l.subscribeKey("error",e=>{e&&this.paymentState==="in-progress"&&(this.paymentState="error",this.updateMessages())})}loaderTemplate(){const e=me.state.themeVariables["--w3m-border-radius-master"],n=e?parseInt(e.replace("px",""),10):4,r=this.getPaymentIcon();return w`
      <wui-flex justifyContent="center" alignItems="center" style="position: relative;">
        ${r?w`<wui-wallet-image size="lg" imageSrc=${r}></wui-wallet-image>`:null}
        <wui-loading-thumbnail radius=${n*9}></wui-loading-thumbnail>
      </wui-flex>
    `}getPaymentIcon(){const e=l.state.currentPayment;if(e){if(e.type==="exchange"){const n=e.exchangeId;if(n)return l.getExchangeById(n)?.imageUrl}if(e.type==="wallet"){const n=h.getAccountData()?.connectedWalletInfo?.icon;if(n)return n;const r=h.state.activeChain;if(!r)return;const i=j.getConnectorId(r);if(!i)return;const a=j.getConnectorById(i);return a?ye.getConnectorImage(a):void 0}}}successTemplate(){return w`<wui-icon size="xl" color="success" name="checkmark"></wui-icon>`}errorTemplate(){return w`<wui-icon size="xl" color="error" name="close"></wui-icon>`}};x.styles=Me;Y([N()],x.prototype,"loadingMessage",void 0);Y([N()],x.prototype,"subMessage",void 0);Y([N()],x.prototype,"paymentState",void 0);x=Y([ie("w3m-pay-loading-view")],x);const Ye=3e5;async function Ve(t){return l.handleOpenPay(t)}async function rt(t,e=Ye){if(e<=0)throw new u(c.INVALID_PAYMENT_CONFIG,"Timeout must be greater than 0");try{await Ve(t)}catch(n){throw n instanceof u?n:new u(c.UNABLE_TO_INITIATE_PAYMENT,n.message)}return new Promise((n,r)=>{let i=!1;const a=setTimeout(()=>{i||(i=!0,g(),r(new u(c.GENERIC_PAYMENT_ERROR,"Payment timeout")))},e);function o(){if(i)return;const T=l.state.currentPayment,C=l.state.error,V=l.state.isPaymentInProgress;if(T?.status==="SUCCESS"){i=!0,g(),clearTimeout(a),n({success:!0,result:T.result});return}if(T?.status==="FAILED"){i=!0,g(),clearTimeout(a),n({success:!1,error:C||"Payment failed"});return}C&&!V&&!T&&(i=!0,g(),clearTimeout(a),n({success:!1,error:C}))}const d=F("currentPayment",o),m=F("error",o),E=F("isPaymentInProgress",o),g=$e([d,m,E]);o()})}function at(){return l.getExchanges()}function it(){return l.state.currentPayment?.result}function ot(){return l.state.error}function ct(){return l.state.isPaymentInProgress}function F(t,e){return l.subscribeKey(t,e)}function $e(t){return()=>{t.forEach(e=>{try{e()}catch{}})}}const ut={network:"eip155:8453",asset:"native",metadata:{name:"Ethereum",symbol:"ETH",decimals:18}},lt={network:"eip155:8453",asset:"0x833589fcd6edb6e08f4c7c32d4f71b54bda02913",metadata:{name:"USD Coin",symbol:"USDC",decimals:6}},dt={network:"eip155:84532",asset:"native",metadata:{name:"Ethereum",symbol:"ETH",decimals:18}},pt={network:"eip155:1",asset:"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",metadata:{name:"USD Coin",symbol:"USDC",decimals:6}},mt={network:"eip155:10",asset:"0x0b2c639c533813f4aa9d7837caf62653d097ff85",metadata:{name:"USD Coin",symbol:"USDC",decimals:6}},yt={network:"eip155:42161",asset:"0xaf88d065e77c8cC2239327C5EDb3A432268e5831",metadata:{name:"USD Coin",symbol:"USDC",decimals:6}},ft={network:"eip155:137",asset:"0x3c499c542cef5e3811e1192ce70d8cc03d5c3359",metadata:{name:"USD Coin",symbol:"USDC",decimals:6}},ht={network:"solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",asset:"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",metadata:{name:"USD Coin",symbol:"USDC",decimals:6}},wt={network:"eip155:1",asset:"0xdAC17F958D2ee523a2206206994597C13D831ec7",metadata:{name:"Tether USD",symbol:"USDT",decimals:6}},Et={network:"eip155:10",asset:"0x94b008aA00579c1307B0EF2c499aD98a8ce58e58",metadata:{name:"Tether USD",symbol:"USDT",decimals:6}},gt={network:"eip155:42161",asset:"0xFd086bC7CD5C481DCC9C85ebE478A1C0b69FCbb9",metadata:{name:"Tether USD",symbol:"USDT",decimals:6}},At={network:"eip155:137",asset:"0xc2132d05d31c914a87c6611c10748aeb04b58e8f",metadata:{name:"Tether USD",symbol:"USDT",decimals:6}},It={network:"solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",asset:"Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB",metadata:{name:"Tether USD",symbol:"USDT",decimals:6}},Nt={network:"solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",asset:"native",metadata:{name:"Solana",symbol:"SOL",decimals:9}};export{x as W3mPayLoadingView,I as W3mPayView,yt as arbitrumUSDC,gt as arbitrumUSDT,ut as baseETH,dt as baseSepoliaETH,lt as baseUSDC,pt as ethereumUSDC,wt as ethereumUSDT,at as getExchanges,ct as getIsPaymentInProgress,ot as getPayError,it as getPayResult,Ve as openPay,mt as optimismUSDC,Et as optimismUSDT,rt as pay,ft as polygonUSDC,At as polygonUSDT,Nt as solanaSOL,ht as solanaUSDC,It as solanaUSDT};
